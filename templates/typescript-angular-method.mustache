/**
* {{&summary}}
* @method
{{#externalDocs}}
* @see {@link {{&url}}|{{#description}}{{&description}}{{/description}}{{^description}}External docs{{/description}}}
{{/externalDocs}}
* @name {{&className}}#{{&methodName}}
{{#parameters}}
    {{^isSingleton}} * @param {{=<% %>=}}{<%&type%>}<%={{ }}=%> {{&camelCaseName}} - {{&description}}{{/isSingleton}}
{{/parameters}}
*/
{{&methodName}}(parameters: {
{{#parameters}}{{^isSingleton}}{{&camelCaseName}}{{&cardinality}}: {{> type}},
{{/isSingleton}}{{/parameters}}
      $queryParameters?: {},
    },
    opts: {
      $timeout?: number;
      $refresh?: boolean;
      $cache?: {
        get:(key: string) => string|Object
        put:(key: string, value: string|Object, options?: {}) => void;
      };
      $cacheItemOpts?: {};
    } = {}): ng.IPromise<{{&tsType}}|any> {
    let domain = this.domain;
    let path = '{{&path}}';
    {{#hasBody}}
    let body;
    {{/hasBody}}
    let queryParameters = {};
    let headers = {};
    {{#hasForm}}
    let form = {};
    {{/hasForm}}
    let deferred = this.$q.defer();

{{#headers}}
    headers['{{&name}}'] = [{{&value}}];
{{/headers}}

{{#parameters}}
    {{#isQueryParameter}}
        {{#isSingleton}}
            queryParameters['{{&name}}'] = '{{&singleton}}';
        {{/isSingleton}}
        {{^isSingleton}}
            {{#isPatternType}}
                Object.keys(parameters).forEach(function(parameterName) {
                    if(new RegExp('{{&pattern}}').test(parameterName)){
                        queryParameters[parameterName] = parameters[parameterName];
                    }
                });
            {{/isPatternType}}
            {{^isPatternType}}
                if(parameters['{{&camelCaseName}}'] !== undefined){
                    queryParameters['{{&name}}'] = parameters['{{&camelCaseName}}'];
                }
            {{/isPatternType}}
        {{/isSingleton}}
    {{/isQueryParameter}}

    {{#isPathParameter}}
        path = path.replace('{{=<% %>=}}{<%&name%>}<%={{ }}=%>', parameters['{{&camelCaseName}}']);
    {{/isPathParameter}}

    {{#isHeaderParameter}}
        {{#isSingleton}}
            headers['{{&name}}'] = '{{&singleton}}';
        {{/isSingleton}}
        {{^isSingleton}}
            if(parameters['{{&camelCaseName}}'] !== undefined){
                headers['{{&name}}'] = parameters['{{&camelCaseName}}'];
            }
        {{/isSingleton}}
    {{/isHeaderParameter}}

    {{#isBodyParameter}}
        if(parameters['{{&camelCaseName}}'] !== undefined){
            body = parameters['{{&camelCaseName}}'];
        }
    {{/isBodyParameter}}

    {{#isFormParameter}}
        {{#isSingleton}}
            form['{{&name}}'] = '{{&singleton}}';
        {{/isSingleton}}
        {{^isSingleton}}
            if(parameters['{{&camelCaseName}}'] !== undefined){
                form['{{&name}}'] = parameters['{{&camelCaseName}}'];
            }
        {{/isSingleton}}
    {{/isFormParameter}}
{{/parameters}}

if(parameters.$queryParameters) {
    Object.keys(parameters.$queryParameters).forEach(function(parameterName){
        var parameter = parameters.$queryParameters[parameterName];
        queryParameters[parameterName] = parameter;
    });
}

var url = domain + path;
{{#isGET}}
var cached = opts.$cache && opts.$cache.get(url);
if(cached !== undefined && opts.$refresh !== true) {
    deferred.resolve(cached);
    return deferred.promise;
}
{{/isGET}}
var options = {
    timeout: opts.$timeout,
    method: '{{method}}',
    url: url,
    params: queryParameters,
{{#hasBody}}
    data: body,
{{/hasBody}}
{{#hasForm}}
    data: form,
{{/hasForm}}
    headers: headers
};
{{! I don't think this is actually needed #hasBody} }
if(typeof(body) === 'object' && !(body.constructor.name === 'Buffer')) {
    options.headers['Content-Type'] = 'application/json';
{ {/hasBody}}
{{#hasForm}}
options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
options.transformRequest = {{&className}}.transformRequest;
{{/hasForm}}

this.$http(options).then(function(response: ng.IHttpPromiseCallbackArg<{{&tsType}}|any>){
    if(response.status >= 400) {
        deferred.reject(response);
    } else {
        {{#hasVoidReturn}}
        deferred.resolve();
        {{/hasVoidReturn}}
        {{^hasVoidReturn}}
        deferred.resolve(response.data);
        if(opts.$cache !== undefined) {
            opts.$cache.put(url, response.data, opts.$cacheItemOpts ? opts.$cacheItemOpts : {});
        }
        {{/hasVoidReturn}}
    }
}, deferred.reject);

return deferred.promise;

}
