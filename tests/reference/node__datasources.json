/*jshint -W069 */
/**
 * <p>These resources can be used to manage and explore data sources. The endpoint of these resources is based on your project name. For instance, if your 28.io project is named <code>myproject</code>, your endpoint for this API will be will be: <code>http://myproject.28.io/v1/_datasources</code>.</p>
 * @class Test
 * @param {(string|object)} [domainOrOptions] - The project domain or options object. If object, see the object's optional properties.
 * @param {string} [domainOrOptions.domain] - The project domain
 * @param {object} [domainOrOptions.token] - auth token - object with value property and optional headerOrQueryName and isQuery properties
 */
var Test = (function() {
    'use strict';

    var request = require('request');
    var Q = require('q');

    function Test(options) {
        var domain = (typeof options === 'object') ? options.domain : options;
        this.domain = domain ? domain : 'http://portal.28.io/v1';
        if (this.domain.length === 0) {
            throw new Error('Domain parameter must be specified as a string.');
        }
    }

    /**
     * Lists all data sources
     * @method
     * @name Test#listDatasources
     * @param {string} token - A project token.
     * 
     */
    Test.prototype.listDatasources = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'GET',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Lists all data sources in a specific category
     * @method
     * @name Test#listCategoryDatasources
     * @param {string} category - The data source category.
     * @param {string} token - A project token.
     * 
     */
    Test.prototype.listCategoryDatasources = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'GET',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Creates a new data source
     * @method
     * @name Test#createDatasource
     * @param {string} category - The data source category.
     * @param {string} name - The name of the data source. The data source name can contain any alphabetic letter, numbers, dots, or dashes, and must start with an alphabetic letter.
     * @param {string} token - A project token.
     * @param {boolean} default - Whether the new data source will be the default one for its category. The default value is false.
     * @param {string} credentials - The data sources credentials as JSON.
     * 
     */
    Test.prototype.createDatasource = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        if (parameters['name'] !== undefined) {
            queryParameters['name'] = parameters['name'];
        }

        if (parameters['name'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: name'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters['default'] !== undefined) {
            queryParameters['default'] = parameters['default'];
        }

        if (parameters['credentials'] !== undefined) {
            body = parameters['credentials'];
        }

        if (parameters['credentials'] === undefined) {
            deferred.reject(new Error('Missing required body parameter: credentials'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'POST',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Retrieves a data source credentials
     * @method
     * @name Test#getDatasource
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} token - A project token.
     * 
     */
    Test.prototype.getDatasource = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'GET',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Updates a data source
     * @method
     * @name Test#updateDatasource
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} token - A project token.
     * @param {string} name - The new name of the data source. If not specified the data source is not renamed.
     * @param {boolean} default - Whether the data source should become (if true) or cease to be (if false) the default one for its category. If not specified the data source does not change its default status.
     * @param {string} credentials - The new data sources credentials as JSON. If not specified the data sources credentials are not changed
     * 
     */
    Test.prototype.updateDatasource = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters['name'] !== undefined) {
            queryParameters['name'] = parameters['name'];
        }

        if (parameters['default'] !== undefined) {
            queryParameters['default'] = parameters['default'];
        }

        if (parameters['credentials'] !== undefined) {
            body = parameters['credentials'];
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'PATCH',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Removes a data source
     * @method
     * @name Test#removeDatasource
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} token - A project token.
     * 
     */
    Test.prototype.removeDatasource = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'DELETE',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * List available collections
     * @method
     * @name Test#getDatasourceContents
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} token - A project token.
     * 
     */
    Test.prototype.getDatasourceContents = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}/contents';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'GET',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Creates collection
     * @method
     * @name Test#createCollection
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} name - The name of the new collection.
     * @param {string} token - A project token.
     * 
     */
    Test.prototype.createCollection = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}/contents';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        if (parameters['name'] !== undefined) {
            queryParameters['name'] = parameters['name'];
        }

        if (parameters['name'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: name'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'POST',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Retrieves metadata about a collection
     * @method
     * @name Test#getCollectionMetadata
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} collection - The collection name.
     * @param {string} token - A project token.
     * 
     */
    Test.prototype.getCollectionMetadata = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}/contents/{collection}';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        path = path.replace('{collection}', parameters['collection']);

        if (parameters['collection'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: collection'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'GET',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Removes a collection
     * @method
     * @name Test#removeCollection
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} collection - The collection name.
     * @param {string} token - A project token.
     * 
     */
    Test.prototype.removeCollection = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}/contents/{collection}';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        path = path.replace('{collection}', parameters['collection']);

        if (parameters['collection'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: collection'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'DELETE',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Lists collection items
     * @method
     * @name Test#listCollection
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} collection - The collection name.
     * @param {string} token - A project token.
     * @param {integer} offset - The index of the first item from which to start listing the collection items. Default is 1.
     * @param {integer} limit - The number of collection items to list. Default is 10.
     * @param {boolean} expand - Whether to include the serialized item in the listing. The default value is false.
     * @param {string} Accept - Serialization format.
     * 
     */
    Test.prototype.listCollection = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}/contents/{collection}/items';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        headers['Accept'] = ['*/*', 'application/xml', 'application/xhtml+xml', 'text/html', 'text/plain', 'application/json', 'application/28.io+json'];

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        path = path.replace('{collection}', parameters['collection']);

        if (parameters['collection'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: collection'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters['offset'] !== undefined) {
            queryParameters['offset'] = parameters['offset'];
        }

        if (parameters['limit'] !== undefined) {
            queryParameters['limit'] = parameters['limit'];
        }

        if (parameters['expand'] !== undefined) {
            queryParameters['expand'] = parameters['expand'];
        }

        if (parameters['Accept'] !== undefined) {
            headers['Accept'] = parameters['Accept'];
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'GET',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Inserts an item into a collection
     * @method
     * @name Test#insertInCollection
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} collection - The collection name.
     * @param {string} token - A project token.
     * @param {string} item - The item to insert.
     * 
     */
    Test.prototype.insertInCollection = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}/contents/{collection}/items';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        path = path.replace('{collection}', parameters['collection']);

        if (parameters['collection'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: collection'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters['item'] !== undefined) {
            body = parameters['item'];
        }

        if (parameters['item'] === undefined) {
            deferred.reject(new Error('Missing required body parameter: item'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'POST',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Truncates a collection
     * @method
     * @name Test#truncateCollection
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} collection - The collection name.
     * @param {string} token - A project token.
     * 
     */
    Test.prototype.truncateCollection = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}/contents/{collection}/items';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        path = path.replace('{collection}', parameters['collection']);

        if (parameters['collection'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: collection'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'DELETE',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Retrieves a collection item
     * @method
     * @name Test#getItem
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} collection - The collection name.
     * @param {string} identifier - The item identifier.
     * @param {string} token - A project token.
     * 
     */
    Test.prototype.getItem = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}/contents/{collection}/items/{identifier}';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        path = path.replace('{collection}', parameters['collection']);

        if (parameters['collection'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: collection'));
            return deferred.promise;
        }

        path = path.replace('{identifier}', parameters['identifier']);

        if (parameters['identifier'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: identifier'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'GET',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Updates a collection item
     * @method
     * @name Test#updateItem
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} collection - The collection name.
     * @param {string} identifier - The item identifier.
     * @param {string} token - A project token.
     * @param {string} item - The new item.
     * 
     */
    Test.prototype.updateItem = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}/contents/{collection}/items/{identifier}';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        path = path.replace('{collection}', parameters['collection']);

        if (parameters['collection'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: collection'));
            return deferred.promise;
        }

        path = path.replace('{identifier}', parameters['identifier']);

        if (parameters['identifier'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: identifier'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters['item'] !== undefined) {
            body = parameters['item'];
        }

        if (parameters['item'] === undefined) {
            deferred.reject(new Error('Missing required body parameter: item'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'PUT',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };
    /**
     * Removes an item from a collection
     * @method
     * @name Test#removeItem
     * @param {string} category - The data source category.
     * @param {string} datasource - The data source name.
     * @param {string} collection - The collection name.
     * @param {string} identifier - The item identifier.
     * @param {string} token - A project token.
     * 
     */
    Test.prototype.removeItem = function(parameters) {
        if (parameters === undefined) {
            parameters = {};
        }
        var deferred = Q.defer();

        var domain = this.domain;
        var path = '/_datasources/{category}/{datasource}/contents/{collection}/items/{identifier}';

        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};

        path = path.replace('{category}', parameters['category']);

        if (parameters['category'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: category'));
            return deferred.promise;
        }

        path = path.replace('{datasource}', parameters['datasource']);

        if (parameters['datasource'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: datasource'));
            return deferred.promise;
        }

        path = path.replace('{collection}', parameters['collection']);

        if (parameters['collection'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: collection'));
            return deferred.promise;
        }

        path = path.replace('{identifier}', parameters['identifier']);

        if (parameters['identifier'] === undefined) {
            deferred.reject(new Error('Missing required path parameter: identifier'));
            return deferred.promise;
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = parameters['token'];
        }

        if (parameters['token'] === undefined) {
            deferred.reject(new Error('Missing required query parameter: token'));
            return deferred.promise;
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters)
                .forEach(function(parameterName) {
                    var parameter = parameters.$queryParameters[parameterName];
                    queryParameters[parameterName] = parameter;
                });
        }

        var req = {
            method: 'DELETE',
            uri: domain + path,
            qs: queryParameters,
            headers: headers,
            body: body
        };
        if (Object.keys(form).length > 0) {
            req.form = form;
        }
        if (typeof(body) === 'object' && !(body instanceof Buffer)) {
            req.json = true;
        }
        request(req, function(error, response, body) {
            if (error) {
                deferred.reject(error);
            } else {
                if (/^application\/(.*\\+)?json/.test(response.headers['content-type'])) {
                    try {
                        body = JSON.parse(body);
                    } catch (e) {

                    }
                }
                if (response.statusCode === 204) {
                    deferred.resolve({
                        response: response
                    });
                } else if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({
                        response: response,
                        body: body
                    });
                } else {
                    deferred.reject({
                        response: response,
                        body: body
                    });
                }
            }
        });

        return deferred.promise;
    };

    return Test;
})();

exports.Test = Test;